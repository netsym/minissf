/*
 * muxtree :- a tree of multiplexers.
 *
 * Muxtree is a model that builds a simple network of ssf
 * entities. The topology of this model is a tree: the leaves of the
 * tree are traffic sources and the interior nodes (including the
 * root) of the tree are multiplexers. Messages are generated from the
 * source node and travel through a series of multiplexers until it
 * reaches the root of the tree. Within each multiplexer, there is a
 * FIFO queue that has a buffer with a finite size and each message is
 * given a constant service time. Messages could be dropped if a
 * buffer overflow occurs. 
 */

#ifndef __MUXTREE_H__
#define __MUXTREE_H__

#include "ssf.h"
using namespace minissf;

// commenting out the following to disable verbose debugging info
//#define MUXTREE_DEBUG

#define MUXTREE_LEVELS 3 // number of levels of multiplexers
#define MUXTREE_FANIN  8 // fan-in at each multiplexer
#define TRANSMISSION_DELAY VirtualTime(1.0, VirtualTime::SECOND) // channel delay
#define SRC_ENTITY_IAT VirtualTime(1.0, VirtualTime::SECOND) // inter-arrival time
#define MUX_ENTITY_BUFSIZ 6 // size of the FIFO queue
#define MUX_ENTITY_MST VirtualTime(1.0, VirtualTime::SECOND) // mean service time (in seconds)

/*
 * Each user message, which travels from the source node through
 * multiplexer nodes and ultimately to the tree root, is an ssf
 * event. It contains the time at which the message was created, and
 * the id of the source node where it was created.
 */
class MyMessage : public Event {
 public:
  VirtualTime time; // generation time of the message
  int srcid;    // id of the source node

  // the constructor
  MyMessage(VirtualTime tm, int sid) : time(tm), srcid(sid) {}

  // the copy constructor and the clone method are required by ssf,
  // so that, when the message is crossing processor boundaries, the
  // message will be copied implicitly by the ssf runtime system
  MyMessage(const MyMessage& msg) : Event(msg), time(msg.time), srcid(msg.srcid) {}
  virtual Event* clone() { return new MyMessage(*this); }

  // The following method is also required by ssf, so that, when the
  // message is sent across memory space bounaries (in a distributed
  // simulation environment), the message needs to be serialized into
  // a platform-independent byte array, so that at the remote machine,
  // the ssf instance can unpack (i.e., deserialize) the byte array
  // into a new event object
  virtual int pack(char* buf, int bufsiz) {
    /*
    CompactDataType* cdt = new CompactDataType;
    cdt->add_virtual_time(time);
    cdt->add_int(srcid);
    int pksiz = cdt->pack(buf, bufsiz);
    delete cdt;
    return pksiz;
    */
    int pos = 0;
    CompactDataType::serialize(time.get_ticks(), buf, bufsiz, &pos);
    CompactDataType::serialize(srcid, buf, bufsiz, &pos);
    return pos;
  }

  // this is a factory method of this event object, which is required
  // by ssf so that the message can be copied to another ssf instance
  // running on a separate memory space in a distributed memory
  // environment; we need to register this factory method using the
  // SSF_REGISTER_EVENT macro so that ssf knows what to call to create
  // a new event of this type
  static Event* create_my_message(char* buf, int bufsiz) {
    /*
    CompactDataType* cdt = new CompactDataType;
    cdt->unpack(buf, bufsiz);
    VirtualTime tm; int sid;
    if(cdt->get_virtual_time(&tm) != 1 || 
       cdt->get_int(&sid) != 1) {
      delete cdt;
      return 0; // return null if anything unexpected happen
    } else {
      delete cdt;
      return new MyMessage(tm, sid); // return the newly created event object
    }
    */
    int pos = 0;
    int64 tick; int sid;
    CompactDataType::deserialize(tick, buf, bufsiz, &pos);
    CompactDataType::deserialize(sid, buf, bufsiz, &pos);
    return new MyMessage(VirtualTime(tick), sid);
  }

  // every user-defined event class must be declared using this macro
  SSF_DECLARE_EVENT(MyMessage);
}; /*class MyMessage*/

/*
 * SourceEntity is an entity class that models a traffic source. All
 * source nodes are leaves of the mux tree. Each object generates
 * messages using an exponentially distributed random variable with a
 * specified mean inter-arrival time.
 */
class SourceEntity : public Entity {
 public:
  int id; // id of the source node
  long nsent; // statistics: number of messages generated by this multiplexer
  LehmerRandom rng; // the random number generator (it's a state variable)
  outChannel* oc; // output channel used to connect to a multiplexer

  // the constructor
  SourceEntity(int myid);
}; /*class SourceEntity*/

/* 
 * EmitProcess represents a ssf process that generates messages for
 * the traffic source node.
 */
class EmitProcess : public Process {
public:
  // The constructor.
  EmitProcess(SourceEntity* owner) : Process(owner) {}

  // The traffic source node is the owner entity of this process.
  SourceEntity* owner() { return (SourceEntity*)Process::owner(); }

  // The method is the process's starting procedure.
  virtual void action(); //! SSF PROCEDURE
}; /*class EmitProcess*/

/*
 * MultiplexerEntity is an entity class that models a multiplexer in
 * this model. Each multiplexer enques each incoming message in a FIFO
 * queue, serves the message in the front of the queue with a constant
 * service time, and then forwards it to the multiplexer at a higher
 * level of the tree.
 */
class MultiplexerEntity : public Entity {
public:
  int level;  // the tree level this multiplexer is at
  int id;     // the id of the multiplexer (within its tree level)
  LehmerRandom rng; // the random number generator

  long nrcvd; // statistics: number of received messages
  long nlost; // statistics: number of messages dropped due to overflow
  long nsent; // statistics: number of messages sent from this multiplexer

  MyMessage** buf; // buffered messages are stored in a circular list
  MyMessage* inservice; // the message currently being processed
  int tail;   // index to the tail of the buffer
  int head;   // index to the head of the buffer
  int qlen;   // number of messages enqueued

  inChannel* ic;  // input channel used to receive messages (from preivous multiplexer or source node)
  outChannel* oc; // output channel to send messages (to the multiplexer at the next tree level)

  inChannel* int_ic;  // internal input channel
  outChannel* int_oc; // internal output channel

  SourceEntity** src_array; // source entities, if this mux is at the last level

  // the constructor and the destructor
  MultiplexerEntity(int mylevel, int myid);
  virtual ~MultiplexerEntity();

  virtual void init();   // create the source node if the multiplexer is at level 0
  virtual void wrapup(); // dump statistics at the end of simulation

  // the procedure for handling arrivals
  void arrive(Process*); //! SSF PROCEDURE

  // the procedure for servicing jobs
  void serve(Process*); //! SSF PROCEDURE
}; /*class MultiplexerEntity*/

class ArriveProcess : public Process {
public:
  ArriveProcess(MultiplexerEntity* owner) : Process(owner) {}
  virtual void action(); //! SSF PROCEDURE
};

class ServeProcess : public Process {
public:
  ServeProcess(MultiplexerEntity* owner) : Process(owner) {}
  virtual void action(); //! SSF PROCEDURE
};

#endif /*__MUXTREE_H__*/

/*
 * Copyright (c) 2011-2014 Florida International University.
 *
 * Permission is hereby granted, free of charge, to any individual or
 * institution obtaining a copy of this software and associated
 * documentation files (the "software"), to use, copy, modify, and
 * distribute without restriction.
 *
 * The software is provided "as is", without warranty of any kind,
 * express or implied, including but not limited to the warranties of
 * merchantability, fitness for a particular purpose and
 * noninfringement.  In no event shall Florida International
 * University be liable for any claim, damages or other liability,
 * whether in an action of contract, tort or otherwise, arising from,
 * out of or in connection with the software or the use or other
 * dealings in the software.
 *
 * This software is developed and maintained by
 *
 *   Modeling and Networking Systems Research Group
 *   School of Computing and Information Sciences
 *   Florida International University
 *   Miami, Florida 33199, USA
 *
 * You can find our research at http://www.primessf.net/.
 */
