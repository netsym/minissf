More Examples
-------------

Earlier we introduced the helloworld example. In this section, we use more examples to demonstrate how to develop simulation
models in MiniSSF. 

The Muxtree Example
===================

The muxtree model is located at the ``examples/muxtree`` directory under the MiniSSF root directory. The source code is given in two files: a header file ``muxtree.h``, and a source file ``muxtree.cc``.

The muxtree model represents a simplistic network of multiplexer switches. The network topology is a tree, where the leaves of the tree are traffic sources. Messages are generated from the traffic sources at the leaves of the tree, and travel through the multiplexer switches toward the root of the tree. At each multiplexer switch, the messages are buffered in a FIFO queue before entering service. Each message in service waits for some random service time, which is exponentially distributed, before the message is sent to the multiplexer switch at the next level, until it reaches the root. Messages may be dropped if a buffer overflow occurs.

The topology of the model is a tree. There are two parameters that control the shape of the tree: the number of input links to each multiplexer switch (``MUXTREE_FANIN``) and the height of the multiplexer tree (``MUXTREE_LEVELS``). Both parameters are predefined macros in the program.

The Model
*********

The muxtree example use two types of entities to represent the traffic sources and the multiplexers, respectively. Connections are set up between instances of these entities so that they form a tree topology. This is achieved by mapping an output channel of an entity to an input channel of another entity, so they can communicate with one another. Messages generated by the traffic source entities are represented as events. Messages are sent from the traffic source entities to the multiplexer entities, which forward the messages until they reach the root of the tree.

Source Entities
***************

A traffic source is modeled by the ``SourceEntity`` class, which is derived from the ``Entity`` class. A traffic source generates messages with a random inter-arrival time from an exponential distribution and sends the messages out from its output channel. The output channel is mapped to the input channel of another entity that represents a multiplexer switch at the next tree level. The definition of the ``SourceEntity`` class (appeared in ``muxtree.h``) is shown below::

   class SourceEntity : public Entity {
    public:
     int id;
     long nsent;
     LehmerRandom rng;
     outChannel* oc;

     SourceEntity(int myid);
   };

All state variables related to the traffic source entity must be defined within the entity class. In the ``SourceEntity`` class, the variables include an integer to identify the source entity (``id``), a long integer to count the number of messages that has been generated by this source entity (``nsent``), a pseudo random number generator (we use the Lehmer random number generator here) for sampling message inter-arrival times (``rng``), and an output channel owned by this source entity out through which messages are sent (``oc``). 

The ``SourceEntity`` class defines only one method, the constructor; the code of the constructor (located in ``muxtree.cc``) is shown below::

   SourceEntity::SourceEntity(int myid) : 
       id(myid), nsent(0), rng((MUXTREE_FANIN^MUXTREE_LEVELS)+myid), oc(0)
   {
     oc = new outChannel(this, TRANSMISSION_DELAY);

     char icname[128];
     sprintf(icname, "IN_%d_%d", MUXTREE_LEVELS-1, id/MUXTREE_FANIN);
     oc->mapto(icname);

     new EmitProcess(this);
   }

The constructor initializes the entity's state variables by setting the identifier of this new source object, resetting the message count used for statistics, and initializing the pseudo random number generator with a random seed, which is derived from the identifier. The constructor also creates an output channel and map it to another input channel of a given name. The name of the input channel that this output channel is mapped to is chosen carefully so that the source entities connects to the corresponding multiplexer switch of the next level in the tree.

An ``EmitProcess`` instance is created at the end of the constructor. This will be the process used by the source entity to generate messages. The ``EmitProcess`` class is defined in the ``muxtree.h`` and is shown below::

   class EmitProcess : public Process {
    public:
     EmitProcess(SourceEntity* owner) : Process(owner) {}
     SourceEntity* owner() { return (SourceEntity*)Process::owner(); }

     virtual void action();
   };

The ``EmitProcess`` class is derived from the ``Process`` class. A process in MiniSSF is regarded as part of an entity that specifies the evolution of the entity's state; a process can be blocked either by waiting on an input channel for an event to arrive or by waiting for a specified period of simulation time to elapse. 

The ``EmitProcess`` class defines three methods. The constructor of this class does nothing more than simply invoking the constructor of its base class. The ``EmitProcess`` class also overrides the ``owner()`` method, which returns the owner entity of this process and then casts it into the correct source entity type. The ``action()`` method is the starting procedure of this process, which will be invoked when the process is created.

The code for the ``action()`` method is located in ``muxtree.cc`` and is shown as follows::

   void EmitProcess::action() {
     VirtualTime tm;
     MyMessage* msg;

     for(;;) {
       tm = owner()->rng.exponential(1.0/SRC_ENTITY_IAT);
       waitFor(tm);

       msg = new MyMessage(now(), owner()->id);
       owner()->oc->write((Event*&)msg);
       owner()->nsent++;
     }
   }


The ``action()`` method starts once the process starts to run after an ``EmitProcess`` instance is created. In the ``action()`` method, the control enters a loop, in which the process waits for an exponentially distributed simulation time before generating a message event and then sending it out from the output channel. Calling the ``waitFor`` function is a wait statement: the process will be blocked for the specified amount of simulation time, which is obtained from an exponential distribution (using the pseudo random number generator ``rng``, defined as a state variable in the source entity). The ``exponential()`` method generates a random number from the exponential distribution using a mean arrival rate, which is the reciprocate of the mean inter-arrival time, which is defined as macro ``SRC_ENTITY_IAT``.

After the wait, a ``MyMessage`` instance is created, which represents a generated message. The ``MyMessage`` class is derived from the ``Event`` class. We describe the ``MyMessage`` class momentarily. For now, it suffices to know that the constructor of the class takes two arguments: the current simulation time (which is returned from the ``now()`` method) and the source entity's id. The message is sent out from the output channel by calling the ``write()`` method of the ``outChannel`` class. Note that the forever loop is actually unnecessary. In MiniSSF, if the control reaches the end of a starting procedure, the process will restart from the beginning of the starting procedure.

Message Events
**************

The messages generated from the source entities at the leaves of the tree will be sent to the multiplexer entities and will finally reach the root of the tree if not dropped at an intermediate node. The messages are represented as an event called ``MyMessage`` derived from the ``Event`` class::

   class MyMessage : public Event {
    public:
     VirtualTime time;
     int srcid;

     MyMessage(VirtualTime tm, int sid) : time(tm), srcid(sid) {}
     MyMessage(const MyMessage& msg) : Event(msg), time(msg.time), srcid(msg.srcid) {}
     virtual Event* clone() { return new MyMessage(*this); }

     virtual int pack(char* buf, int bufsiz) {
         int pos = 0;
    	 CompactDataType::serialize(time.get_ticks(), buf, bufsiz, &pos);
    	 CompactDataType::serialize(srcid, buf, bufsiz, &pos);
    	 return pos;
     }
     static Event* create_my_message(char* buf, int bufsiz) {
        int pos = 0;
     	int64 tick; int sid;
    	CompactDataType::deserialize(tick, buf, bufsiz, &pos);
    	CompactDataType::deserialize(sid, buf, bufsiz, &pos);
    	return new MyMessage(VirtualTime(tick), sid);
     }

     SSF_DECLARE_EVENT(MyMessage);
   };

Each message contains two variables: ``time` records the simulation time when this message is generated and ``srcid`` is the source entity id.  The constructor for the ``MyMessage`` class simply initializes these variables. The simulator requires that all event classes must include the copy constructor and the ``clone()`` method. The copy constructor is responsible for copying the member variables. The ``clone()`` method uses the copy constructor; it is invoked by the simulator to create a new instance of this event class which is identical to the original object.

In addition, in order to be able to ship this event to a remote processor in a distributed-memory environment, two additional methods must be provided to support serialization. The ``pack()`` method is invoked by the simulator to convert this event into a machine-independent byte array (i.e., serialization). We use the serialize methods of the ``CompactDataType`` class to pack the primitive data types into the byte array. 

When the byte array is delivered to the remote machine, the simulator will invoke the factory method of this event class to *unpack* this byte array and create an exact copy of the original event. The factory method can be any static method that takes a pointer to the buffer and the size of the buffer as the arguments and returns a pointer to a generic ``Event`` object. The factory method uses the deserialize methods of the ``CompactDataType`` class to unpack the data. from the byte array. Note that the order of serialization (in which the data are inserted into the byte array) must match the order of deserialization (in which the data are retrieved from the byte array). A new ``MyMessage`` object is then created and returned.

It is important to remember that all event classes (those derived from the ``Event`` base class) must be declared to the simulator using the ``SSF_DECLARE_EVENT`` macro. In addition, each event class must also register its factory method in the source file (in ``muxtree.cc``) using the ``SSF_REGISTER_EVENT`` macro::

   SSF_REGISTER_EVENT(MyMessage, MyMessage::create_my_message);

Multiplexer Entities
********************

The multiplexer switches in this model is represented by the ``MultiplexerEntity`` class, which is defined as follows::

   class MultiplexerEntity : public Entity {
    public:
     int level, id;
     LehmerRandom rng;
     long nrcvd, nlost, nsent;

     MyMessage** buf;
     MyMessage* inservice;
     int tail, head, qlen;

     inChannel* ic;
     outChannel* oc;

     inChannel* int_ic;
     outChannel* int_oc;

     SourceEntity** src_array;

     MultiplexerEntity(int mylevel, int myid);
     virtual ~MultiplexerEntity();

     virtual void init();
     virtual void wrapup();

     void arrive(Process*);
     void serve(Process*);
   };

Same as the ``SourceEntity`` class, the ``MultiplexerEntity`` class is also derived from the ``Entity`` class. This class contains two integers to identify the position of the multiplexer in the tree: the level and the index id. The class also contains three long integers used for collecting statistics during the simulation. The multiplexer contains a FIFO queue. Messages arrived at the multiplexer will first enter the FIFO queue if the queue is not full. When the previous message is sent out from the multiplexer, the message at the head of the queue will enter the server and will be serviced for some time before leaving the multiplexer. The state of the queue, including the messages in the queue, is therefore part of the state of the entity. The model uses a circular list to represent the queue (``buf``), with an integer (``head``) storing the index to the message at the head of the queue and another integer (``tail``) storing the index to the message at the tail of the queue. The variable ``qlen`` keeps the number of messages currently in the queue.

Each multiplexer entity has two communication channels: an input channel, ``ic``, which is used to receive messages from either a source entity or a multiplexer entity at the previous tree level, and an output channel, ``oc``, which is used to send messages to the next tree level. Each multiplexer entity also defines two additional (internal) channels to communicate between the arrival process and the service process of this entity, which we describe below. The class has one constructor and one destructor defined. Also, the ``MultiplexerEntity`` class overrides two methods at the ``Entity`` class: the ``init()`` method, which we use to initialize this entity (including creating the source entities if the multiplexer is at level 0) at the start of simulation, and the ``wrapup()`` method, which we use to wrap up this entity (including writing out the statistics) before the simulation finishes.

There are two processes defined for each multiplexer entity. The arrival process waits for incoming messages from the input channel, enqueues them, and notifies the service process if the queue was empty before the arrival. The service process dequeues the message at the front of the queue, waits for a fixed amount of simulation time to model the message being serviced, then sends the message out from the output channel.  We create the two process classes, correspondingly::

  class ArriveProcess : public Process {
  public:
    ArriveProcess(MultiplexerEntity* owner) : Process(owner) {}
    virtual void action() { ((MultiplexerEntity*)owner())->arrive(this); }
  };

  class ServeProcess : public Process {
  public:
    ServeProcess(MultiplexerEntity* owner) : Process(owner) {}
    virtual void action() { ((MultiplexerEntity*)owner())->serve(this); }
  };

The ``action()`` methods are the starting procedures. They call the ``arrive()`` method and the ``serve()`` method of the corresponding ``MultiplexerEntity`` class.

Let's look at the constructor of the ``MultiplexerEntity`` class, which initializes the state variables, creates the channels, and starts the arrival and service processes::

   MultiplexerEntity::MultiplexerEntity(int mylevel, int myid) :
     level(mylevel), id(myid), rng((MUXTREE_FANIN^mylevel)+myid),
     nrcvd(0), nlost(0), nsent(0), buf(0), inservice(0),
     tail(0), head(0), qlen(0), src_array(0)
   {
     buf = new MyMessage*[MUX_ENTITY_BUFSIZ];

     char icname[128];
     sprintf(icname, "IN_%d_%d", level, id);
     ic = new inChannel(this, icname);

     oc = new outChannel(this, TRANSMISSION_DELAY);
     if(level > 0) {
       sprintf(icname, "IN_%d_%d", level-1, id/MUXTREE_FANIN);
       oc->mapto(icname);
     }

     int_ic = new inChannel(this);
     int_oc = new outChannel(this);
     int_oc->mapto(int_ic);

     Process* arrive_proc = new ArriveProcess(this); 
     arrive_proc->waitsOn(ic);

     Process* serve_proc = new ServeProcess(this);
     serve_proc->waitsOn(int_ic);
   }

The external input channel ``ic`` must have a globally unique name, which is obtained using the tree level and the index id of the multiplexer entity. Output channels of other entities can therefore be mapped to the corresponding input channels of the multiplexer entities using this name to form the tree structure. Both the arrival process and the service process are created afterwards. The arrival process by default is waiting on the external input channel ``ic``, and similarly the service process by default is waiting on the internal input channel ``int_ic``. The default behavior is set using the ``waitsOn`` method.

The destructor of the ``MultiplexerEntity`` class needs to reclaim the memory used by the queue. And if there are messages stored in the queue, they need to be reclaimed as well. We also reclaim the array that stores the references to the source entities (created by the ``init()`` method which we describe later. All entities are reclaimed by the simulator at the end of the simulation. The destructor code is shown below::

   MultiplexerEntity::~MultiplexerEntity() {
     if(inservice) delete inservice;
     while(qlen-- > 0) delete buf[(head++)%MUX_ENTITY_BUFSIZ];
     delete[] buf;
     if(src_array) delete[] src_array;
   }

The ``init()`` method of an entity is called by the runtime system immediately after the entity is created. We use this opportunity to create the traffic source entities as the leave nodes if the multiplexer entity is at the last tree level (next to the tree leaves). In this case, the source entities are aligned with the multiplexer entity that creates them. Recall that entity alignment is an important concept in SSF. Each entity in SSF has a timeline. Entities sharing the same timeline (in which case we call these entities {\em coaligned}) are guaranteed to advance their simulation time synchronously. Therefore, these entities can access (i.e., read and write) each other's state variables during the simulation. This is important because, in parallel simulation, entities in general are running on different processors and therefore may process events at different simulation time. Thus accessing a state variable of an entity that is not coaligned may cause a timing error. In our case, the multiplexer entities at the last tree level and the source entities at the leaves are coaligned, which means we can access the state of the source entities from the multiplexer entity)::

   void MultiplexerEntity::init() {
     if(level == MUXTREE_LEVELS-1) {
       src_array = new SourceEntity*[MUXTREE_FANIN];
       for(int i=0; i<MUXTREE_FANIN; i++) {
         src_array[i] = new SourceEntity(id*MUXTREE_FANIN+i);
      	 src_array[i]->alignto(this);
       }
     }
   }

The entity's ``wrapup()`` method is called by the simulator before the entity is about to be destroyed (which happens only at the end of the simulation). We use this opportunity to collect the statistics of the source entities if the multiplexer entity is next to the tree leaves::

   void MultiplexerEntity::wrapup() {
     if(level == MUXTREE_LEVELS-1) {
       for(int i=0; i<MUXTREE_FANIN; i++)
         nsent += src_array[i]->nsent;
       delete[] src_array;
       src_array = 0;
     }
   }

The ``arrive()`` method is the main procedure for the arrival process and is shown below::

   void MultiplexerEntity::arrive(Process* p) {
     for(;;) {
       p->waitOn();

       MyMessage* msg = (MyMessage*)ic->activeEvent();
       nrcvd++;

       if(qlen == MUX_ENTITY_BUFSIZ) {
         nlost++; delete msg;
       } else {
         qlen++; buf[(tail++)%MUX_ENTITY_BUFSIZ] = msg;
	 if(qlen == 1) {
	   Event* evt = new Event();
	   int_oc->write(evt);
         }
       }
     }
   }

The process waits on the input channel ``ic`` for a message to arrive, and upon message arrival puts the message at the tail of the FIFO queue. And if the queue was empty before the newly arrived message, the arrival process will send an event through the internal output channel ``oc`` to the service process, which is blocked on the internal input channel ``int_ic``, which is mapped to the internal output channel. The ``service()`` method is the main procedure for the service process and is shown below::

   void MultiplexerEntity::serve(Process* p) {
     for(;;) {
       p->waitOn();

       while(qlen > 0) {
         inservice = buf[(head++)%MUX_ENTITY_BUFSIZ]; qlen--;
	 VirtualTime d = rng.exponential(1.0/MUX_ENTITY_MST);
	 p->waitFor(d);
	 oc->write((Event*&)inservice);
	 nsent++;
       }
     }
   }

The service process first waits on the internal input channel. In this way, whenever a message arrives at an empty queue, the arrival process will send an event through the internal channel and wake up the service process. For each message in the queue, the service process removes the message from the front of the queue, and then simulates the message processing by suspending itself for a period of time sampled from an exponential distribution with the mean service time ``MUX_ENTITY_MST``, before sending the message out from the output channel.

The Main Function
*****************

The main function creates the entities for the muxtree model and starts the simulation. The code is listed in the following::

   int main(int argc, char** argv) {
     ssf_init(argc, argv);

     if(argc != 2) {
       if(!ssf_machine_index()) {
         fprintf(stderr, "Usage: %s <sim_time>\n", argv[0]);
	 ssf_print_options(stderr);
       }
       ssf_abort(1);
     }
     VirtualTime end_time(argv[1]);
     if(end_time <= 0) {
       if(!ssf_machine_index()) {
         fprintf(stderr, "ERROR: invalid simulation end time: %s\n", argv[1]);
       }
       ssf_abort(2);
     }

     VECTOR(MultiplexerEntity*) mux_vector;
     for(int level=0, nnodes=1; level<MUXTREE_LEVELS; level++, nnodes*=MUXTREE_FANIN) {
       for(int index=ssf_machine_index(); index<nnodes; index+=ssf_num_machines()) {
         MultiplexerEntity* mux = new MultiplexerEntity(level, index);
	 mux_vector.push_back(mux);
       }
     }

     ssf_start(end_time);

     long nsent = 0, nrcvd = 0, nlost = 0;
     for(VECTOR(MultiplexerEntity*)::iterator iter = mux_vector.begin();
         iter != mux_vector.end(); iter++) {
       nsent += (*iter)->nsent;
       nrcvd += (*iter)->nrcvd;
       nlost += (*iter)->nlost;
     }

     if(ssf_num_machines() > 1) {
       long sendbuf[3], recvbuf[3];
       sendbuf[0] = nsent; sendbuf[1] = nrcvd; sendbuf[2] = nlost;
       MPI_Reduce(sendbuf, recvbuf, 3, MPI_LONG, MPI_SUM, 0, 
                  ssf_machine_communicator());
       nsent = recvbuf[0]; nrcvd = recvbuf[1]; nlost = recvbuf[2];
     }
     if(!ssf_machine_index()) {
       printf("simulation results: nrcvd=%ld, nlost=%ld, nsent=%ld\n", 
       	      nrcvd, nlost, nsent);
     }

     ssf_finalize();
     return 0;
   }

The ``ssf_init()`` method needs to be called at the start of the main function. It processes the command-line options and filter out MiniSSF specific arguments. Similarly, the ``ssf_finalize()`` method needs to be called at the end of the main function before it returns. It assures the simulation ends correctly. 

After ``ssf_init()``, we process the command-line options. The program requires one argument, which is the total simulation time. Note that MiniSSF is following the SPMD (single program multiple data) paradigm; that is, the main function is run at each distributed machine. We use ``ssf_machine_index()``, which returns the rank of the simulator instance, to differentiate them. When the command-line argument is wrong, we only allow the first simulator instance to print out the error message. In this case, the ``ssf_abort()`` method is called to terminate the simulation abruptly. 

The model is created one tree level at a time starting from the root of the tree (at level 0).  As mentioned above, MiniSSF is SPMD: the main function is called at each distributed machine that participates the simulation run. Accordingly, the model must be built in a distributed fashion. In this example, we only build a portion of the tree that is assigned to the machine.  Partitioning is achieved by assigning multiplexer entities at each tree level to different machines in a round-robin fashion. We only instantiate those multiplexer entities with indices equal to the index (or rank) of the machine (returned from the ``ssf_machine_index()`` method) modulus the total number of distributed machines (returned form the ``ssf_num_machines()`` method). The entities are stored in a vector called ``mux_vector``, which we later use to collect statistical results.

The ``ssf_start()`` method starts the simulation; it runs until the simulation has reached the given simulation end time. When the method returns, the simulation has finished. We then iterate through all the multiplex entities created for this machine and sum up the number of messages sent, received, and lost by the multiplexer entities. Recall that the multiplexer entities at the last level of the tree also collect results from the source entities in the ``wrapup()`` method. The ``wrapup()`` methods are called before the call to the ``ssf_start()`` method returns. Therefore, the statistics include all entities of the model. For distributed simulation, we use ``MPI_Reduce()`` to sum up the values at each simulator instance and then machine 0 prints the statistics before ``ssf_finalize()`` is called. The ``ssf_finalize()`` method reclaims all MiniSSF data structures, including all simulation states.

